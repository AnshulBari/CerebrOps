input {
  beats {
    port => 5044
  }
  
  file {
    path => "/app/logs/*.log"
    start_position => "beginning"
    sincedb_path => "/usr/share/logstash/data/sincedb"
    codec => "json"
    tags => ["cerebrops-app"]
  }
}

filter {
  # Parse JSON logs from CerebrOps application
  if [message] {
    if [message] =~ /^{.*}$/ {
      json {
        source => "message"
        target => "parsed"
      }
      
      if [parsed] {
        mutate {
          add_field => { 
            "log_level" => "%{[parsed][level]}"
            "log_message" => "%{[parsed][message]}"
            "log_module" => "%{[parsed][module]}"
          }
        }
      }
    } else {
      # Parse standard Flask logs
      grok {
        match => { 
          "message" => "%{TIMESTAMP_ISO8601:timestamp} %{LOGLEVEL:log_level} %{WORD:module} %{GREEDYDATA:log_message}" 
        }
      }
    }
  }
  
  # Add system information
  mutate {
    add_field => { 
      "application" => "cerebrops"
      "environment" => "${ENVIRONMENT:development}"
    }
  }
  
  # Parse timestamp
  if [timestamp] {
    date {
      match => [ "timestamp", "ISO8601" ]
      target => "@timestamp"
    }
  }
  
  # Add severity based on log level
  if [log_level] {
    if [log_level] == "ERROR" or [log_level] == "CRITICAL" {
      mutate { add_field => { "severity" => "high" } }
    } else if [log_level] == "WARNING" or [log_level] == "WARN" {
      mutate { add_field => { "severity" => "medium" } }
    } else {
      mutate { add_field => { "severity" => "low" } }
    }
  }
  
  # Extract metrics from log messages
  if [log_message] =~ /CPU/ {
    grok {
      match => { 
        "log_message" => "CPU.*?(?<cpu_usage>\d+\.?\d*)%" 
      }
      tag_on_failure => ["_grokparsefailure_cpu"]
    }
    
    if [cpu_usage] {
      mutate {
        convert => { "cpu_usage" => "float" }
        add_tag => ["metrics", "cpu"]
      }
    }
  }
  
  if [log_message] =~ /memory|Memory/ {
    grok {
      match => { 
        "log_message" => "(?i)memory.*?(?<memory_usage>\d+\.?\d*)%" 
      }
      tag_on_failure => ["_grokparsefailure_memory"]
    }
    
    if [memory_usage] {
      mutate {
        convert => { "memory_usage" => "float" }
        add_tag => ["metrics", "memory"]
      }
    }
  }
  
  # Detect anomalies in logs
  if [log_level] == "ERROR" or [log_message] =~ /(?i)(error|exception|failed|timeout)/ {
    mutate {
      add_tag => ["anomaly_candidate"]
      add_field => { "anomaly_type" => "error" }
    }
  }
  
  if [cpu_usage] and [cpu_usage] > 90 {
    mutate {
      add_tag => ["anomaly_candidate"]
      add_field => { "anomaly_type" => "high_cpu" }
    }
  }
  
  if [memory_usage] and [memory_usage] > 85 {
    mutate {
      add_tag => ["anomaly_candidate"]
      add_field => { "anomaly_type" => "high_memory" }
    }
  }
}

output {
  elasticsearch {
    hosts => ["elasticsearch:9200"]
    index => "cerebrops-logs-%{+YYYY.MM.dd}"
    
    # Use document templates for different log types
    template_name => "cerebrops"
    template => "/usr/share/logstash/templates/cerebrops-template.json"
    template_overwrite => true
  }
  
  # Output anomaly candidates to separate index
  if "anomaly_candidate" in [tags] {
    elasticsearch {
      hosts => ["elasticsearch:9200"]
      index => "cerebrops-anomalies-%{+YYYY.MM.dd}"
    }
  }
  
  # Debug output (remove in production)
  stdout {
    codec => rubydebug { metadata => true }
  }
}
